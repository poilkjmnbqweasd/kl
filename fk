--[[NOTE: due to a recent roblox change this script will most likely wont work,More info: https://www.youtube.com/post/Ugkxd2msc7Mh8Ue0bX2_XsE5xQiFY2mYJDSa]]--Made by Rouxhaver--R6 required--type "/e follow <OUIAAD2>" to change the target--REQUIRED ACCESSORYS:--https://www.roblox.com/catalog/48474313/Red-Roblox-Cap--https://www.roblox.com/catalog/451220849/Lavender-Updo--https://www.roblox.com/catalog/62234425/Brown-Hair--https://www.roblox.com/catalog/63690008/Pal-Hair--https://www.roblox.com/catalog/62724852/Chestnut-Bun--MAKE SURE to wear 5 other accessorys--Network Library made by 4eyes --Remove this loadstring if you want to use your own netless/netbypass--[[4eyes: https://v3rmillion.net/member.php?action=profile&uid=2636118rouxhaver did not make this!Im simply reposting so I can put more in the loadstring.loadstring(game:HttpGet(""))()]]local Players = game:GetService("Players")local RunService = game:GetService("RunService")local LocalPlayer = Players.LocalPlayer--[[Example script:coroutine.resume(Network["PartOwnership"]["Enable"])--Network.CharacterRelative = falseNetwork.RetainPart(Part)--]]if not getgenv().Network then	getgenv().Network = {		BaseParts = {};		FakeConnections = {};		Connections = {};		Output = {			Enabled = true;			Prefix = "[NETWORK] ";			Send = function(Type,Output,BypassOutput)				if typeof(Type) == "function" and (Type == print or Type == warn or Type == error) and typeof(Output) == "string" and (typeof(BypassOutput) == "nil" or typeof(BypassOutput) == "boolean") then					if Network["Output"].Enabled or BypassOutput then						Type(Network["Output"].Prefix..Output);					end;				elseif Network["Output"].Enabled then					error(Network["Output"].Prefix.."Output Send Error : Invalid syntax.");				end;			end;		};		LostParts = {};		CharacterRelative = true;		LastCharacter = nil;		TryKeep = true; --loop attempts to		PartOwnership = {			PreMethodSettings = {};			Enabled = false;		};	}	Network["Output"].Send(print,": Loading.")	Network["RetainPart"] = function(Part,Silent,ReturnFakePart) --function for retaining ownership of unanchored parts		assert(Network["PartOwnership"]["Enabled"], Network["Output"].Prefix.." RetainPart Error : PartOwnership is Disabled.")		assert(typeof(Part) == "Instance" and Part:IsA("BasePart") and not Part:IsGrounded(),Network["Output"].Prefix.."RetainPart Error : Invalid syntax: Arg1 (Part) must be an ungrounded BasePart which is a descendant of workspace.")		if not Part:IsDescendantOf(workspace) then			Network["Output"].Send(error,"RetainPart Error : Invalid syntax: Arg1 (Part) must be an ungrounded BasePart which is a descendant of workspace.")			local Index = table.find(Network["LostParts"],Part)			if Index then				table.remove(Network["LostParts"],Index)			end			return false		end		assert(typeof(Silent) == "boolean" or typeof(Silent) == "nil",Network["Output"].Prefix.."RetainPart Error : Invalid syntax: Arg2 (Silent) must be a boolean or nil.")		assert(typeof(ReturnFakePart) == "boolean" or typeof(ReturnFakePart) == "nil",Network["Output"].Prefix.."RetainPart Error : Invalid syntax: Arg3 (ReturnFakePart) must be a boolean or nil.")		if not table.find(Network["BaseParts"],Part) and not table.find(Network["LostParts"],Part) then			table.insert(Network["BaseParts"],Part)			Part.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)			if not Silent then				Network["Output"].Send(print,"PartOwnership Output : PartOwnership applied to BasePart "..Part:GetFullName()..".")			end			if ReturnFakePart then				local workspaceParts = {}				return FakePart			end		else			Network["Output"].Send(warn,"RetainPart Warning : PartOwnership not applied to BasePart "..Part:GetFullName()..", as it already active.")			return false		end	end	Network["RemovePart"] = function(Part,Silent) --function for removing ownership of unanchored part		assert(typeof(Part) == "Instance" and Part:IsA("BasePart"),Network["Output"].Prefix.."RemovePart Error : Invalid syntax: Arg1 (Part) must be a BasePart.")		local Index1 = table.find(Network["BaseParts"],Part)		local Index2 = table.find(Network["LostParts"],Part)		if Index1 then			table.remove(Network["BaseParts"],Index1)		else			if not Silent then				Network["Output"].Send(warn,"RemovePart Warning : BasePart "..Part:GetFullName().." not found in BaseParts table.")			end			return		end		if Index2 then			table.remove(Network["LostParts"],Index2)		end		if not Silent then			Network["Output"].Send(print,"RemovePart Output: PartOwnership removed from BasePart "..Part:GetFullName()..".")		end	end	Network["PartOwnership"]["PartCoroutine"] = coroutine.create(function(Part)		if Part:IsDescendantOf(workspace) then			if Network.CharacterRelative then				local Character = Network["LastCharacter"];				if not Character.PrimaryPart then					for _,Inst in pairs(Character:GetDescendants()) do						if Inst:IsA("BasePart") then							Character.PrimaryPart = Inst							break						end					end				end				if Character and Character.PrimaryPart then					local Distance = (Character.PrimaryPart.Position - Part.Position).Magnitude					if Distance > gethiddenproperty(LocalPlayer,"MaximumSimulationRadius") and not isnetworkowner(Part) then						Network["Output"].Send(warn,"PartOwnership Warning : PartOwnership not applied to BasePart "..Part:GetFullName()..", as it is more than "..gethiddenproperty(LocalPlayer,"MaximumSimulationRadius").." studs away.")						Network["RemovePart"](Part)						if not Part:IsGrounded() then							table.insert(Network["LostParts"],Part)						else							Network["Output"].Send(warn,"PartOwnership Warning : PartOwnership not applied to BasePart "..Part:GetFullName()..", as it is grounded.")						end					end				else					Network["Output"].Send(warn,"PartOwnership Warning : PartOwnership not applied to BasePart "..Part:GetFullName()..", as the LocalPlayer Character's PrimaryPart does not exist.")				end			end			Part.AssemblyLinearVelocity = (Part.AssemblyLinearVelocity.Unit+Vector3.new(.01,.01,.01))*(50+math.cos(tick()*10))		else			Network["RemovePart"](Part)		end	end)	Network["PartOwnership"]["Enable"] = coroutine.create(function() --creating a thread for network stuff		if not Network["PartOwnership"]["Enabled"] then			Network["PartOwnership"]["Enabled"] = true			Network["PartOwnership"]["PreMethodSettings"].ReplicationFocus = LocalPlayer.ReplicationFocus			LocalPlayer.ReplicationFocus = workspace			Network["PartOwnership"]["PreMethodSettings"].SimulationRadius = gethiddenproperty(LocalPlayer,"SimulationRadius")			Network["PartOwnership"]["Connection"] = RunService.Stepped:Connect(function()				Network["LastCharacter"] = pcall(function() return LocalPlayer.Character end) or Network["LastCharacter"]				sethiddenproperty(LocalPlayer,"SimulationRadius",1/0)				coroutine.wrap(function()					for _,Part in pairs(Network["BaseParts"]) do --loop through parts and do network stuff						coroutine.resume(Network["PartOwnership"]["PartCoroutine"],Part)						--[==[ [[by 4eyes btw]] ]==]--					end				end)()				coroutine.wrap(function()					for _,Part in pairs(Network["LostParts"]) do						Network.RetainPart(Part,true)					end				end)()			end)			Network["Output"].Send(print,"PartOwnership Output : PartOwnership enabled.")		else			Network["Output"].Send(warn,"PartOwnership Output : PartOwnership already enabled.")		end	end)	Network["PartOwnership"]["Disable"] = coroutine.create(function()		if Network["PartOwnership"]["Connection"] then			Network["PartOwnership"]["Connection"]:Disconnect()			LocalPlayer.ReplicationFocus = Network["PartOwnership"]["PreMethodSettings"].ReplicationFocus			sethiddenproperty(LocalPlayer,"SimulationRadius",Network["PartOwnership"]["PreMethodSettings"].SimulationRadius)			Network["PartOwnership"]["PreMethodSettings"] = {}			for _,Part in pairs(Network["BaseParts"]) do				Network["RemovePart"](Part)			end			for Index,Part in pairs(Network["LostParts"]) do				table.remove(Network["LostParts"],Index)			end			Network["PartOwnership"]["Enabled"] = false			Network["Output"].Send(print,"PartOwnership Output : PartOwnership disabled.")		else			Network["Output"].Send(warn,"PartOwnership Output : PartOwnership already disabled.")		end	end)	Network["Output"].Send(print,": Loaded.")endcoroutine.resume(Network["PartOwnership"]["Enable"])--"More"for i,v in pairs(LocalPlayer.Character:GetDescendants()) do  if v:IsA("Accessory") then    Network.RetainPart(v.Handle)  endendfor i,lplr in pairs(game:GetService("Players"):GetPlayers()) do	lplr.Character:WaitForChild("Humanoid").DisplayName = lplr.DisplayName.."\n\@"..lplr.Name    lplr.CharacterAdded:Connect(function()        lplr.Character:WaitForChild("Humanoid").DisplayName = lplr.DisplayName.."\n\@"..lplr.Name    end)endgame:GetService("Players").PlayerAdded:Connect(function(lplr)    repeat		wait()	until lplr.Character ~= nil	lplr.Character:WaitForChild("Humanoid").DisplayName = lplr.DisplayName.."\n\@"..lplr.Name    lplr.CharacterAdded:Connect(function()        lplr.Character:WaitForChild("Humanoid").DisplayName = lplr.DisplayName.."\n\@"..lplr.Name    end)end)local_player = game:GetService("Players").LocalPlayercharacter = local_player.Charactercharacter.Hat1:SetAttribute("Minion",true)character.LavanderHair:SetAttribute("Minion",true)character.Robloxclassicred:SetAttribute("Minion",true)character["Kate Hair"]:SetAttribute("Minion",true)character["Pal Hair"]:SetAttribute("Minion",true)game:GetService("StarterGui"):SetCore("SendNotification",{	Title = "FE Minions V2",	Text = "Made by Rouxhaver",	Icon = "rbxassetid://12997341656"})for _,hat in pairs(character:GetChildren()) do	if hat:IsA("Accessory") and hat:GetAttribute("Minion") == true then		local minion = Instance.new("Model",workspace)		minion.Name = "Minion"		local hrp = Instance.new("Part",minion)		hrp.Position = Vector3.new(0, 10, 0)		hrp.Size = Vector3.new(1, 2, 1)		hrp.Transparency = 1		hrp.Name = "HumanoidRootPart"		local torso = Instance.new("Part",minion)		torso.Position = hrp.Position		torso.Size = Vector3.new(1, 2 ,1)		torso.Name = "Torso"		tors
